# Complete Performance Calculation Audit - Deep Dive

## Executive Summary

**CRITICAL FINDING**: We have 3 DIFFERENT performance calculation formulas being used across the application, NONE of which match the intended design documented in the migrations.

**Result**: Inconsistent performance numbers shown to users depending on where they look.

---

## The Intended Design (From Migration)

**File**: `migrations/versions/20251005_add_snapshot_cash_fields.py` (lines 19-32)

```python
Modified Dietz Formula with max_cash_deployed:
Return = (V_end - V_start - CF) / (V_start + W * CF)

Where:
- V_start = stock_value_start + cash_proceeds_start
- V_end = stock_value_end + cash_proceeds_end
- CF = max_cash_deployed_end - max_cash_deployed_start (net deposits)
- W = time-weighted factor

Example:
Aug 1: stock=$10, cash=$5, deployed=$10 → Portfolio=$15
Sep 1: stock=$15, cash=$10, deployed=$15 → Portfolio=$25
CF = $5 (new capital deployed)
Return = ($25 - $15 - $5) / ($15 + 0.5*$5) = 28.6% (NOT 66.7%!)
```

**This formula was NEVER IMPLEMENTED anywhere.**

---

## What's Actually Being Used

### Formula 1: Simple Percentage (generate_chart_from_snapshots)

**File**: `leaderboard_utils.py` lines 1125-1135
**Used by**: 
- Chart cache generation (UserPortfolioChartCache)
- Leaderboard calculations (via chart cache)

```python
first_value = snapshots[0].total_value  # ❌ Wrong baseline!
for snapshot in snapshots:
    performance_pct = ((snapshot.total_value - first_value) / first_value) * 100
```

**Problems**:
- ❌ Uses first snapshot value as baseline (arbitrary based on when account created)
- ❌ If user joined in June, YTD calculation starts from June not Jan 1
- ❌ Doesn't use max_cash_deployed at all
- ❌ No time-weighting
- ❌ Wrong baseline entirely

**Where it flows**:
1. Market-close cron → `update_leaderboard_cache()` → `generate_chart_from_snapshots()` → UserPortfolioChartCache
2. `/leaderboard` route → LeaderboardCache (which uses chart cache data)
3. Dashboard `/api/portfolio/performance/<period>` → Tries chart cache FIRST

---

### Formula 2: Wrong Modified Dietz (calculate_modified_dietz_return)

**File**: `portfolio_performance.py` lines 541-580
**Used by**:
- Dashboard live calculation fallback (when chart cache doesn't exist)
- Some admin diagnostic routes

```python
beginning_value = snapshots[0].total_value  # ❌ Should be V_start formula
ending_value = snapshots[-1].total_value    # ❌ Should be V_end formula

for snapshot in snapshots[1:]:
    weighted_cash_flow += snapshot.cash_flow * weight  # ❌ Should use max_cash_deployed
    net_cash_flow += snapshot.cash_flow

return (ending_value - beginning_value - net_cash_flow) / denominator
```

**Problems**:
- ❌ Uses `total_value` instead of `stock_value + cash_proceeds`
- ❌ Uses `snapshot.cash_flow` (legacy field) instead of max_cash_deployed changes
- ❌ Uses first snapshot as baseline (wrong when user joined mid-period)
- ✅ Does time-weight cash flows (correct approach, wrong data)

**Where it flows**:
1. Dashboard `/api/portfolio/performance/<period>` → Falls back here if cache missing
2. Some diagnostic/admin routes

---

### Formula 3: Simple max_cash_deployed (calculate_performance)

**File**: `cash_tracking.py` lines 175-193
**Used by**: ❓ Unknown - possibly legacy or unused

```python
performance = ((current_value - user.max_cash_deployed) / user.max_cash_deployed) * 100
```

**Evaluation**:
- ✅ Uses max_cash_deployed (correct baseline!)
- ✅ Simple and fast
- ❌ No time-weighting (may be okay for our use case)
- ❓ NOT CALLED by dashboard, leaderboard, or charts!

---

## Data Flow Analysis

### Path 1: Dashboard Charts (Most Common)

```
User loads dashboard → 
/api/portfolio/performance/<period> →
├─ TRY: UserPortfolioChartCache (Formula 1: Simple %)
│  └─ Generated by: generate_chart_from_snapshots() 
│     └─ Called by: market-close cron
│
├─ FALLBACK 1: Session cache (5 min)
│
└─ FALLBACK 2: Live calculation (Formula 2: Wrong Modified Dietz)
   └─ PortfolioPerformanceCalculator.get_performance_data()
      └─ calculate_modified_dietz_return()
```

**Current Reality**: 
- Chart cache exists (count=40) → Uses Formula 1 (Simple %)
- Shows WRONG performance (e.g., YTD 25.87% when it should be different)

---

### Path 2: Leaderboard

```
User views /leaderboard?period=YTD →
get_leaderboard_data() →
├─ TRY: LeaderboardCache (period='YTD_all_auth')
│  └─ Returns cached leaderboard data
│     └─ Data source: calculate_leaderboard_data()
│        └─ Uses: generate_chart_from_snapshots() (Formula 1)
│
└─ FALLBACK: calculate_leaderboard_data() (Formula 1)
   └─ Calls generate_chart_from_snapshots() for each user
```

**Current Reality**:
- Uses Formula 1 (Simple %) exclusively
- Same wrong calculations as dashboard charts

---

### Path 3: Public Portfolio Pages (if applicable)

❓ Need to verify if these exist and what they call

---

## Caching Layers - Complete Analysis

### Layer 1: UserPortfolioChartCache (Database)
**Table**: `user_portfolio_chart_cache`
**Populated by**: `generate_chart_from_snapshots()` 
**When**: Market-close cron (daily at 4PM EDT)
**Formula used**: Formula 1 (Simple % - WRONG)
**Current count**: 40 entries (5 users × 8 periods)
**TTL**: Regenerated daily
**Issues**:
- ✅ Cache is being created
- ❌ Contains wrong formula results
- ❌ Dashboard shows these wrong values

### Layer 2: LeaderboardCache (Database)  
**Table**: `leaderboard_cache`
**Populated by**: `calculate_leaderboard_data()` → uses chart cache
**When**: Market-close cron (daily at 4PM EDT)
**Formula used**: Formula 1 (Simple % - WRONG, via chart cache)
**Current count**: 48 entries (8 periods × 3 categories × 2 auth variants)
**TTL**: Regenerated daily
**Issues**:
- ✅ Cache is being created
- ❌ Contains wrong formula results (from chart cache)
- ❌ Shows stale Oct 18th data until we regenerated

### Layer 3: Pre-rendered HTML (Database)
**Column**: `leaderboard_cache.rendered_html`
**Status**: NULL for all entries (failed to generate)
**Issues**:
- ❌ Not being generated
- Falls back to dynamic rendering (still uses wrong data)

### Layer 4: Session Cache (Memory)
**Location**: Flask session
**Populated by**: Dashboard route as fallback
**TTL**: 5 minutes
**Formula used**: Formula 2 (Wrong Modified Dietz)
**Issues**:
- Only used when UserPortfolioChartCache missing
- Currently NOT being used (chart cache exists)

---

## Why Dashboard Shows Different Values

**Scenario**: witty-raven YTD performance

1. **Leaderboard shows**: 25.87%
   - Source: LeaderboardCache → chart cache → Formula 1 (Simple %)
   - Calculation: From first snapshot (June) to Oct 25

2. **Dashboard shows**: 28.66%
   - Possibility A: Session cache with Formula 2 (Wrong Modified Dietz)
   - Possibility B: Old chart cache that hasn't refreshed yet
   - Possibility C: Browser cache showing old data

**Need to test**: Clear browser cache and check if values match after regeneration

---

## The Duplication Problem

### Current Architecture (WASTEFUL):

**Function 1**: `generate_chart_from_snapshots()` (leaderboard_utils.py)
- Generates chart data for cache
- Used by: Leaderboard, market-close cron, chart cache generation

**Function 2**: `calculate_modified_dietz_return()` (portfolio_performance.py)
- Calculates final return percentage
- Used by: Dashboard fallback, some admin routes

**Function 3**: `calculate_performance()` (cash_tracking.py)
- Simple max_cash_deployed formula
- Used by: ❓ Possibly nothing!

**Issues**:
- ❌ 3 different functions calculating the same thing
- ❌ 3 different formulas giving different results
- ❌ No single source of truth
- ❌ Each function maintains its own logic
- ❌ Bug fixes must be applied 3 times
- ❌ Impossible to maintain consistency

### What SHOULD Exist:

**ONE FUNCTION** that:
1. Takes (user_id, start_date, end_date)
2. Uses CORRECT Modified Dietz with max_cash_deployed
3. Returns both:
   - Final performance percentage
   - Point-by-point chart data (for visualization)
4. Called by:
   - Dashboard chart route
   - Leaderboard calculation
   - Public portfolio pages
   - Chart cache generation
   - Any diagnostic/admin tools

---

## Best Path Forward (Recommendation)

### Phase 1: Implement Correct Formula (URGENT)

Create **ONE new function** that everyone calls:

```python
def calculate_portfolio_performance(user_id, start_date, end_date, include_chart_data=False):
    """
    Calculate portfolio performance using Modified Dietz with max_cash_deployed.
    
    This is THE SINGLE SOURCE OF TRUTH for all performance calculations.
    
    Args:
        user_id: User ID
        start_date: Period start (e.g., Jan 1 for YTD)
        end_date: Period end (e.g., today)
        include_chart_data: If True, returns point-by-point chart data
        
    Returns:
        {
            'portfolio_return': float,  # Final % return
            'sp500_return': float,      # Benchmark return
            'chart_data': [...] if include_chart_data else None
        }
    """
    snapshots = get_snapshots(user_id, start_date, end_date)
    
    # Use CORRECT formula from migration design
    V_start = snapshots[0].stock_value + snapshots[0].cash_proceeds
    V_end = snapshots[-1].stock_value + snapshots[-1].cash_proceeds
    
    # Calculate max_cash_deployed changes with time-weighting
    weighted_cf = 0.0
    net_cf = 0.0
    prev_deployed = snapshots[0].max_cash_deployed
    
    total_days = (end_date - start_date).days
    for snapshot in snapshots[1:]:
        capital_added = snapshot.max_cash_deployed - prev_deployed
        if capital_added > 0:
            weight = (end_date - snapshot.date).days / total_days
            weighted_cf += capital_added * weight
            net_cf += capital_added
        prev_deployed = snapshot.max_cash_deployed
    
    # Modified Dietz formula
    portfolio_return = (V_end - V_start - net_cf) / (V_start + weighted_cf)
    
    # Generate chart data if requested
    chart_data = None
    if include_chart_data:
        chart_data = generate_chart_points(snapshots, start_date)
    
    # Calculate S&P 500 comparison
    sp500_return = calculate_sp500_return(start_date, end_date)
    
    return {
        'portfolio_return': portfolio_return * 100,
        'sp500_return': sp500_return * 100,
        'chart_data': chart_data
    }
```

### Phase 2: Update All Callers

**Replace in**:
1. `generate_chart_from_snapshots()` → Call new function with `include_chart_data=True`
2. `calculate_modified_dietz_return()` → Call new function (or delete, redirect callers)
3. Dashboard route → Call new function
4. Leaderboard utils → Call new function
5. Market-close cron → Call new function for cache generation

### Phase 3: Regenerate All Caches

Run `/admin/force-regenerate-all-caches` again with correct formula

### Phase 4: Verify Consistency

- Dashboard and leaderboard show same numbers
- Charts use same calculation
- Session cache no longer needed (everything uses DB cache)

---

## Questions for Grok

1. **Is Modified Dietz time-weighting appropriate for our use case?**
   - Users don't make external "deposits"
   - When they add a stock, max_cash_deployed increases
   - Is time-weighting this increase actually meaningful?
   - Or is simple `(value - deployed) / deployed` sufficient?

2. **Chart point calculation strategy:**
   - Should each point recalculate Modified Dietz from period start to that point?
   - Or use simpler formula per-point: `(value_at_point - deployed_at_point) / deployed_at_point`?
   - Trade-off: Accuracy vs simplicity

3. **Consolidation architecture:**
   - Single function with `include_chart_data` parameter?
   - Or separate functions that share core calculation logic?
   - Where should it live? New module?

4. **Backward compatibility:**
   - Should we keep old functions for gradual migration?
   - Or do full cutover since we're fixing bugs anyway?

5. **S&P 500 comparison:**
   - Should benchmark use same time-weighting logic?
   - Or simple start-to-end percentage?
   - Current implementation uses simple percentage

---

## Implementation Priority

**CRITICAL (This Weekend):**
1. ✅ Complete this audit
2. ⏳ Get Grok's input on formula choice
3. ⏳ Implement single unified function
4. ⏳ Update market-close cron to use new function
5. ⏳ Regenerate all caches with correct formula

**HIGH (Next Week):**
6. Update dashboard route to use new function
7. Update leaderboard routes to use new function  
8. Delete or deprecate old calculation functions
9. Add unit tests for new calculation

**MEDIUM (Future):**
10. Pre-render HTML in leaderboard cache
11. Add performance calculation logging
12. Create admin dashboard to verify calculations

---

## Files Needing Changes

**Core calculation**:
1. NEW: `performance_calculator.py` - Single source of truth
2. MODIFY: `leaderboard_utils.py` - Use new calculator
3. MODIFY: `api/index.py` - Dashboard route uses new calculator
4. MODIFY: Market-close cron - Use new calculator
5. DEPRECATE: `portfolio_performance.py` calculate_modified_dietz_return()
6. DEPRECATE: `cash_tracking.py` calculate_performance()

**Testing**:
7. NEW: `test_performance_calculator.py` - Comprehensive unit tests
8. MODIFY: `test_performance.py` - Update to use new calculator

**Documentation**:
9. MODIFY: Migration comments - Note that design is now implemented
10. NEW: `PERFORMANCE_CALCULATION_DESIGN.md` - Document the formula
